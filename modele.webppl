///fold:
// print function 'condProb2Table' for conditional probability tables
var condProb2Table = function(condProbFct, row_names, col_names, 
precision){
  var matrix = map(function(row) {
    map(function(col) {
      _.round(Math.exp(condProbFct(row).score(col)),precision)}, 
        col_names)}, 
                   row_names)
  var max_length_col = _.max(map(function(c) {c.length}, col_names))
  var max_length_row = _.max(map(function(r) {r.length}, row_names))
  var header = _.repeat(" ", max_length_row + 2)+ col_names.join("  ") + 
"\n"
  var row = mapIndexed(function(i,r) { _.padEnd(r, max_length_row, " ") 
+ "  " + 
                       mapIndexed(function(j,c) {
                          _.padEnd(matrix[i][j], c.length+2," ")}, 
                                  col_names).join("") + "\n" }, 
                           row_names).join("")
  return header + row
}
// This function constructs the list of possible personae
var listPersonae = function(universe,relation) {
  //Auxiliary function to iterate over the list
  var fun = function(universe,relation,index1,index2,list) {
    if (index1 === 0) {
      return list;
    }
    else if (index2 === -1) {
      return fun(universe,relation,index1-1,index1-2,list);
    }
    // If the two universe are not antagonists, add to the list
    else if ( relation[universe[index1]] !== universe[index2] 
             && relation[universe[index2]] !== universe[index1]) {
      list.push([universe[index1],universe[index2]]);
      return fun(universe,relation,index1,index2-1,list);
    }
    else  {
      return fun(universe,relation,index1,index2-1,list);
    }
  }
  var size = universe.length;
  return fun(universe,relation,size-1,size-2,[]);
}
var isIn = function(val,arr) {
  return arr.indexOf(val) > -1;
}

///

/// PARAMETERS ///


// List here the set of properties
var universe = ['competent','incompetent','friendly','aloof'];

// List here the relations of incompability
var relation = 
    { 'competent':'incompetent',
      'friendly':'aloof'
    };

var personae = listPersonae(universe,relation);

// Possible utterances
var utterances = ["ing","in"];

// Cost of uttering a message
var cost = function(utterance){
  var table = {
    in:0,
    ing:0
  };
  return table[utterance];
};

// Temperature for the speaker, high temparature means deterministic
// choice for the speaker to chose a message given a persona.
// Low value allows for more variation.
var temperature = 6;
// Temperature for chosing a persona, according to the payoff function
var personaTemperature = 6;

// Payoff function for selecting a persona
// PROBLEM: You have to get the same struct and order than the one
// that personae gives you.
var muFunction = function(personality) {
  var persString = personality.join("-");
  var table = {
    "friendly-competent":6,
    "aloof-competent":4,
    "friendly-incompetent":4,
    "aloof-incompetent":0
  };
  return table[persString];
}

//  Prior distribution of the listener on the personae of the speaker
var personalityPrior = function(prior) {
  if (prior==="uniform") {
    uniformDraw(personae);
  }
  else {
    var prior = prior || [0.3,0.3,0.2,0.2];
    categorical({
      ps:prior,
      vs:personae
  })
  }
};

// Return true if a persona corresponds to the Eckert-Montague field of 
// a variation
// NO LONGER USEFUL! You can get EM Field with getEMField(utt)
var belongToVar = function(utterance,personality) {
  utterance === "in" ? personality !== "aloof-competent":
  utterance === "ing" ? personality !== "friendly-incompetent":
  true
}

var eckertFields = {
  ing:['competent','aloof'],
  in:['incompetent','friendly']
};
// Return the EM Field of an utterance based on the eckertFields var
var getEMField = cache(function(utt) {
  return filter(function(x) { 
    return _.intersection(eckertFields[utt],x).length !== 0;
  },personae);
});


///  END OF PARAMETERS  ///



/// MODEL FUNCTIONS ///



//Pr(P|m) > listener prior belief in a persona given a message
var conditPrior = function(utterance,prior) {
  Infer({model: function() {
    var personality = personalityPrior(prior);
    var uttTruthVal = isIn(personality,getEMField(utterance));
    //var uttTruthVal = belongToVar(utterance,personality);
    condition(uttTruthVal == true)
    return personality
  }})
};

// P_PERS(P) > Probability of chosing a persona
var persDistribution = function() {
  Infer({model: function() {
    var personality = uniformDraw(personae)
    factor(personaTemperature * muFunction(personality))
    return personality
  }})
}

//Ps(m|P) > speaker probability of using m given they want to construct P
//var speaker = function(personality,{tempOpt:temp,priorOpt:prior}) {
var speaker = function(personality,option) {
  
  //var defPrior = Math.exp(Infer({method:'enumerate'},personalityPrior).score(personality));
  //print("DefPrior is:" + defPrior);
  var temp = option.tempOpt == undefined ? temperature : option.tempOpt;
  
  //var prior = prior == undefined ? defPrior : prior;
  //print("prior is :"+ prior);
  
  Infer({model: function() {
    var utterance = uniformDraw(utterances);   
    factor(temp * (conditPrior(utterance,option.priorOpt).score(personality) - 
cost(utterance)))
    return utterance
  }})
};



// P_S(m) > Probability of a speaker of uttering a message
var speakerDistrib = function(utterance) {
  return sum(map(
    function(personality) {
      return Math.exp(persDistribution().score(personality)+speaker(personality).score(utterance));
    },personae))
}

// P_L(P|m)
var listener = function(utterance) {
  Infer({model: function() {
    var personality = personalityPrior()
    observe(speaker(personality),utterance)
    return personality
  }})
}


/// END OF MODEL ///


// Return an array composed of all the integers from a to b (both 
// included)
var rangeN = function(a,b) {
  if (b<a) {
    console.error("rangeN : B should not be inferior to A")
  }
  var aux = function(a,b,acc) {
    acc.push(a);
    b == a ? acc : aux(a+1,b,acc);
  }
  return aux(a,b,[]);
}
// Return a distribution with salient persona with probability p
// and others equally probable
var salientPersonaDis = function(p,salientPersona) {
  if(!isIn(salientPersona,personae)) {
    console.error("The salient persona is not a valid persona");
  }
  if( (p<0) || (p>1) ) {
    console.error("The salient persona probability must be between 0 and 1");
  } 
  
  var aux = function(persona) {
    if (persona === salientPersona) {
      return p
    }
    else {
      //print((1-p)/(personae.length-1));
      return (1-p) / (personae.length-1) ;
    }
  }  
  
  return map(aux,personae);
}
// Return a distribution with all persona with a salient property 
// equally probable
// and others also equally probable
var salientPropertyDis = function(p,salientProperty) {
  if( (p<0) || (p>1) ) {
    console.error("The salient persona probability must be between 0 and 1");
  } 
  var count = function() {
    return filter(function(x){return 
isIn("competent",x)},personae).length;
  } ();
  if(count === 0) {
    console.error("No persona with that property was found.")
  }
  var aux = function(persona) {
    if (isIn(salientProperty,persona)) {
      return p/ count;
    }
    else {
      return (1-p) / (personae.length-count);
    }
  }  
  return map(aux,personae);
}
var speakerPriorPlot = function(utterance,personality,minBound,maxBound) 
{
  var minBound = minBound || 1;
  var maxBound = maxBound || 100;
  
  globalStore.cnt = 0;
  
  var pValues = map(function(x){ return x/100},rangeN(minBound,maxBound));
  var xValues = map(function(p) { return salientPersonaDis(p,personality)},pValues);
    
  var y = map(
  function(x) {
    globalStore.cnt += 1;
    if (globalStore.cnt%10 === 0) {
      print(speaker(personality,{priorOpt:x}));
    }
    return Math.exp(speaker(personality,{priorOpt:x}).score(utterance));},
    xValues);
  //print(zip(xValues,y));
  viz.line(xValues,y,{xLabel:"Prior",yLabel:"Ps(m|p)"});  
};


speakerPriorPlot("in",personae[2]);




// Plot the speaker probability of uttering m for different values of temperature
// minBound and maxBoud are optional parameters for min and max value of 
// temperature
// They are set by default to 1 and 50 respectively
// Future implementation: plot for each m or p ?
// Should check that maxBound > minBound
var speakerTempPlot = function(utterance,personality,minBound,maxBound) 
{
  var minBound = minBound || 0;
  var maxBound = maxBound || 50;
  
  var tempValues = rangeN(minBound,maxBound);
  
  var y = map(
  function(x) { 
    return Math.exp(speaker(personality,{tempOpt:x}).score(utterance));},
    tempValues);
  
  viz.line(tempValues,y,{xLabel:"Temperature",yLabel:"Ps(m|p)"});  
};




/*
print("List of personae and their prior probabilities:");
viz.table(Infer({method:'enumerate'},personalityPrior));
print('');


/// Pr(P|m)

print("Visualization 1:")
display("L's prior belief about S to chose a persona after hearing m")
display(condProb2Table(conditPrior,utterances,personae,2))

print("Vizualization 2:")
print("Listener belief of a persona after hearing 'ing':");
viz.hist(conditPrior("ing"));
print("Listener belief of a persona after hearing 'in':");
viz.table(conditPrior("in"));


/// Ps(m|P)
display("Probability of S to use a message given a persona she wants to 
build:")
display(condProb2Table(speaker,personae,utterances,2));

print("Plot of the probability of uttering 'ing' given she wants to be")
print("friendly and incompetent, for different temperatures")
speakerTempPlot("ing","friendly-competent");


//P_PERS(P)
display("")
display("Probability distribution of chosing a persona :")
viz.table(persDistribution())

//P_S(m)
print("Probability of speaker uttering 'in': ");
print(speakerDistrib("in"));
print("Probability of speaker uttering 'ing': ");
print(speakerDistrib("ing"));
print("")

//P_L(P|m)
print("L's beliefs about a persona after hearing m (here in)")
viz(listener("in"))
display(condProb2Table(listener,utterances,personae,2))
*/

